<!-- uses https://highlightjs.org/
-->

<html>
  <head>
    <link
      rel="shortcut icon"
      href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico"
      type="image/x-i        con"
    />
    <script type="text/javascript">
      var codeType = "JavaScript";
    </script>
    <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
    <link
      rel="stylesheet"
      href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css"
    />
    <link
      rel="stylesheet"
      href="https://byui-cse.github.io/Language-Courses/site/weekly.css"
    />
    <script
      type="text/javascript"
      src="https://byui-cse.github.io/Language-Courses/site/weekly.js"
    ></script>
    <link rel="stylesheet" href="../main.css" />
  </head>

  <body onload="fetchSource()">
    <header class="hero-image">
      <section class="hero-text">
        <h1>CSE 222b: Week 02</h1>
        <p>The Fundamentals</p>
      </section>
    </header>
    <main>
      <h1>Some Similarities and Differences</h1>
      <h3>Shared Operators</h3>
      <p>
        Remember, both Python and Kotlin have C as one of their ancestors.
        Because of this, it is not shocking to find out that they share some of
        the same C-type operators. These include +, -, /, *, ==, !=, &lt, &gt,
        etc. These two websites contain a list of operators for both languages:
        <a
          href="https://www.tutorialspoint.com/python/python_basic_operators.htm"
          target="_blank"
          >Python's list of operators</a
        >
        to
        <a href="https://www.educba.com/kotlin-operators/" target="_blank"
          >Kotlin's list of operators</a
        >. When you compare operators for the two languages, you will find that
        Python has a few that Kotlin does not and that Kotlin has a few that
        Python does not. You will also see that the conditional operators, also
        known as logical operators, exist in both languages but use different
        characters.
      </p>
      <h3>Kotlin's missing operators</h3>
      <p>
        Because Python and Kotlin are different languages and the creators of
        Kotlin had different opinions than those who created Python, there are
        some Python operators you should not expect to find in Kotlin. They are:
      </p>
      <ul>
        <li>// - the floor division operator</li>
        <li>&lt&gt - an alternative to !=</li>
        <li>**= - the exponent and assign operator</li>
        <li>and - the logical and operator</li>
        <li>or - the locical or operator</li>
        <li>not - the logical not operator</li>
      </ul>
      <p>
        Don't get the wrong idea, each of these behaviors can be done in Kotlin,
        they are done differently. Take a look at Table 1 to see how.
      </p>

      <table class="blueTable">
        <caption>
          Table 1: Kotlin Equivalents of Python Operators
        </caption>
        <thead>
          <tr>
            <th>Python</th>
            <th>Kotlin</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>a//b</td>
            <td>a/b (for integers a and b)</td>
          </tr>
          <tr>
            <td>a &lt&gt b</td>
            <td>a != b</td>
          </tr>
          <tr>
            <td>a**=b</td>
            <td>a = a.pow(b) (for floating point type numbers a and b)</td>
          </tr>
          <tr>
            <td>a and b</td>
            <td>a && b</td>
          </tr>
          <tr>
            <td>a or b</td>
            <td>a || b</td>
          </tr>
          <tr>
            <td>not(a and b)</td>
            <td>!(a && b)</td>
          </tr>
        </tbody>
      </table>

      <p>
        Remember, Kotlin has
        <a href="https://www.educba.com/kotlin-operators/" target="_blank"
          >other operators</a
        >
        available as well.
      </p>
      <h3>Variables</h3>
      <p>
        In Python, a variable can hold any type of value and can change the type
        of value it holds. For example, this code is valid in Python.
      </p>
      <pre>
<code class="Python">age = 3
age = 5
age = 4.2
age = 'old'</code></pre>
      <p>
        Kotlin has both variables and constants. Unlike in Python, each variable
        or constant in Kotlin can hold only one type and that type can not
        change. In Kotlin you use the var keyword to declare a variable. Like
        this:
      </p>

      <pre>
<code class="Kotlin">var age = 3
age = 5
age = "4" //compilation failure, type change
age = 4.2 //compilation failure, type change
age = "old" //compilation failure, type change</code></pre>
      <p>
        Kotlin uses what is called
        <a
          style="font-style: italic"
          href="https://www.merriam-webster.com/dictionary/interpolate"
          target="_blank"
          >interpolation</a
        >
        to figure out the type of the variable. In the code above, the compiler
        discovered that the variable age is of type <kbd>Integer</kbd> because 3
        is an <kbd>Integer</kbd> and inserted the <kbd>Int</kbd> keyword into
        the compiled code. In the code snippet below, the compiler discovers
        that the <kbd>height</kbd> variable is of type <kbd>Double</kbd> because
        3.25 is a <kbd>Double</kbd>. <kbd>Double</kbd> being one of Kotlin's
        basic types of floating point numbers.
      </p>

      <pre>
<code class="Kotlin">var height = 3.25
height = 4.2
height = 4//no compilation failure, 4 is converted to a Double
height = age//compilation failure, age's type in the previous example doesn't match
height = "tall"//compilation failure, type change</code></pre>

      <p>
        Here is an example where the compiler interpolates a variable to be of
        type <kbd>String</kbd>.
      </p>

      <pre>
<code class="Kotlin">var name = "Sue"
name = "Gunhilda"
name = "7"
name = 4 //compilation failure, type change
name = age //compiliation failure, age's type in the previous example doesn't match
name = 3.1456778889547637653 //compilation failure, type change</code></pre>

      <h3>Constants</h3>
      <p>
        In Python, constants are declared using an all uppercase name, a
        hold-over from its C ancestor.
      </p>

      <pre>
<code class="Python">PI=3.14</code></pre>
      <p>
        In Kotlin this is done differently. If you are creating class or
        instance constants, upper snake-case names are used. If you are creating
        a local constant, lower snake-case is used. Kotlin requires the use of
        the <kbd>val</kbd> keyword in both of these cases. Like this:
      </p>
      <pre>
<code class="Kotlin">val PI = 3.14
val BASE_VALUE = 3147
val div_result = 3/4</code></pre>
      <p>
        For more information about declaring and using variables and constants
        in Kotlin please go and watch this video:
        <a
          href="https://www.youtube.com/watch?v=iJ11StpAhCk"
          target="_blank"
          rel="noreferrer"
          >Kotlin Variables - var vs. val explained</a
        >.
      </p>
      <h3>But I Want More Control!</h3>
      <p>
        Well...sometimes you do and sometimes you don't. You can tell the Kotlin
        compiler the type of a variable instead of allowing it to interpolate it
        with any
        <a
          href="https://www.tutorialspoint.com/Kotlin/Kotlin_variables.htm"
          target="_blank"
          >basic Kotlin type</a
        >. For example,
      </p>
      <pre>
<code class="Kotlin">val PI : Double = 3.14</code></pre>
      creates a constant called pi of type Float, a floating point number type
      that uses fewer bytes of RAM than a variable of type Double. This code:
      <pre>
<code class="Kotlin">var name : String = "Sue"</code></pre>
      creates a variable called <span style="font-style: italic">name</span> of
      type String and sets the value to be Sue.

      <p>
        Kotlin has something analogous to Python's <kbd>None</kbd>, the
        <kbd>null</kbd> keyword. Declaring the type of a variable is required if
        the variable is initialized to <kbd>null</kbd>. Think about this for a
        minute and take a look at this code snippet:
      </p>
      <pre>
<code class="Kotlin">var city = null</code></pre>
      Here, the compiler can't interpolate a type for the city variable because
      <kbd>null</kbd> has no type! That code won't compile.

      <p>
        Instead, Kotlin will require you to add in the type. You might think,
        based on previous programming experience, that this code snippet would
        compile:
      </p>

      <pre>
<code class="Kotlin">var city:String = null</code></pre>
      <p>
        but that would also be incorrect. This code will also fail to compile
        and you will get an error message that includes a '?' character. This is
        because Kotlin is designed to be safer than other languages you may have
        used. Instead, you would need a variable that is a
        <kbd>Nullable</kbd> type.
      </p>
      <h3>Nullables</h3>
      <p>
        In Kotlin, variables of type Nullable are either <kbd>null</kbd>, or are
        wrappers around regular variable types. For example, this code snippet:
      </p>

      <pre>
<code class="Kotlin">var city:String? = null</code></pre>
      <p>
        reads, in English, like this. "Create a variable called city of type
        String Nullable and set it to null." If you later figure out what the
        city variable should be set to, you can have the city variable wrap a
        value by doing something similar to this.
      </p>
      <pre>
<code class="Kotlin">city = "Kinshasa"</code></pre>
      <p>
        The compiler takes care of all the wrapping up of the string Kinshasa in
        the String Nullable for you. You don't need to add any extra code. After
        assigning "Kinshasa" to the String Nullable city, the city String
        Nullable now is wrapped around the String "Kinshasa".
      </p>
      <p>
        When you have a String Nullable and want to get the string back out, you
        use the <kbd>!!</kbd> operator. Be careful! If you try this
      </p>
      <pre>
<code class="Kotlin">print(city!!)</code></pre>
      <p>
        and city is null, you will get a runtime failure with a message saying
        that an unexpected null was found. These Nullables come in VERY handy
        and it is EASY to check to see if something is null using Nullables.
        Take a look at the following snippet:
      </p>
      <pre><code class="Kotlin">print(city ?: "Unknown")</code></pre>
      <p>
        This code prints "Unknown" if the String Nullable <kbd>city</kbd> is
        <kbd>null</kbd>, or the value wrapped by the String Nullable if
        <kbd>city</kbd> is not <kbd>null</kbd>. This is due to the elvis
        operator, <kbd>?:</kbd>. That's its job. In this case, Kinshasa is
        printed out since city is not <kbd>null</kbd>.
      </p>

      <h3>Wrap Up</h3>

      <p>
        As with all things, there are pluses and minuses of requiring keywords
        like <kbd>var</kbd> and <kbd>val</kbd> and having or not having some
        operators. One disadvantage of requiring <kbd>var</kbd> and
        <kbd>val</kbd> is the extra cluttering of the code with 'unnecessary'
        words. An advantage is explicitness. Everyone that later reads your code
        will know exactly what you meant to have happen. Also, because of this
        explicitness, a variable can't be accidentally declared twice in Kotlin,
        a situation which can produce strange, difficult to debug, bad behavior
        in large Python code sets.
      </p>
      <p>
        Which set of operators to include in a language often depends on the
        languages the creator likes and dislikes. Perhaps the creators of Python
        thought the syntax of Structured Query Language (SQL) was easier to
        understand and so they adopted the <kbd>and</kbd>, <kbd>or</kbd>, and
        <kbd>not</kbd> operators from SQL. The choices the creators made is
        based on opinion. Any other set of operators is just as valid. Don't get
        caught up in the pseudo-religious fervor that some programmers adopt.
        Every language is good at some things and bad at others. This includes
        both Python and Kotlin.
      </p>
      <h1>Arrays</h1>
      <p>
        In Kotlin, arrays can be declared like this if you want an array that
        can be modified.
      </p>
      <pre><code class="Kotlin">var names = arrayOf("Bob","Sue", "Jorge", "Svetlana")</code></pre>
      <p>
        As with variables, if you don't want the compiler to interpolate the
        type of elements the array can hold, you could write this same code
        snippet as
      </p>
      <pre><code class="Kotlin">var names: Array&#60;String&#62; = arrayOf("Bob","Sue", "Jorge", "Svetlana")</code></pre>
      <p>
        If you want an array variable that can only hold the initial array but
        the values in that array can be changed, use the <kbd>val</kbd> keyword
        like this.
      </p>
      <pre><code class="Kotlin">val names = arrayOf("Bob","Sue", "Jorge", "Svetlana")</code></pre>
      These array declarations and assignments probably look very familiar to
      you.
      <p>
        To access elements of an array, use the access operator <kbd>[]</kbd>
      </p>
      <pre><code class="Kotlin">val aName = names[0]</code></pre>
      with zero being the index of the first element in the array. Not only can
      you access the elements of the array, but you can modify them also.
      <pre class="Kotlin"><code>names[2]='George'</code></pre>
      After the previous line of code executes, the third element of the names
      array is George instead of Jorge.
      <p>
        One of the goals of the developers of the Kotlin language is code
        safety. Because of this, if you attempt to modify an array by using an
        index that is too large, your code will produce a runtime error instead
        of writing to memory the application hasn't claimed like some other
        languages do. Yes C, I'm looking at you.
      </p>
      <p>That's why this code</p>

      <pre><code class="Kotlin">names[4]='George'</code></pre>
      fails at runtime.
      <h1>When Arrays Just Won't Work</h1>
      <p>
        While this way of creating arrays is great when you know all or most of
        the values that are to be stored in the array, what if you don't know
        any of them? For example, you are loading a file that has all the values
        for the array, and you need to add them one by one? The tool for this
        job might be a
        <kbd
          ><a
            href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list.html"
            >MutableList</a
          ></kbd
        >.
      </p>
      <p>
        Let's say you are loading a bunch of names from a text file, from a
        database, or across a network. While there are
        <a
          href="https://stackoverflow.com/questions/30430550/how-to-create-an-empty-array-in-Kotlin"
          >many ways</a
        >
        to do this, the preferred way to declare a modifiable, empty array of
        Strings looks like this:
      </p>

      <pre><code class="Kotlin">val names : MutableList&#60;String&#62; = mutableListOf()</code></pre>
      <p>
        The translation of this line of code into English reads like this:
        "Create a value called
        <kbd>names</kbd> of type MutableList that holds String values. Create an
        empty list of Strings and assign it to the the <kbd>names</kbd> value."
        Since there is no way for the compiler to interpolate the type of values
        in an empty array, you have to tell it the type. Also, you have to use
        the
        <a href="https://www.techiedelight.com/add-elements-list-kotlin/"
          ><kbd>add</kbd></a
        >
        or
        <a
          href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set.html"
          ><kbd>set</kbd></a
        >
        Built in Functions(BIF's) to add to the array, not the accessor operator
        <kbd>[]</kbd>. However you can use the accessor operator to get or set a
        value at an existing index. You just can't use it to add new indexes.
      </p>
      <p>
        Kotlin has a lot of
        <a
          href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/"
          >BIF's</a
        >
        that work with arrays. We'll cover some of these BIFs in detail during
        Week 4 of this class.
      </p>
      <h1>Organization and Access</h1>
      <p>
        All computer languages are ways to organize your communication and
        thinking. They are very similar to spoken languages. Each spoken
        language, or family of spoken languages, does this organization
        differently. English sentences often have a structure of Subject-Helper
        Verb-Verb-Predicate. For example: "The boy will bite the dog."" German
        organizes things differently, even though it is closely related to
        English. Sometimes German sentences have a Subject-Helper
        Verb-Predicate-Verb structure, like this "Ich werde das Buch bald
        lesen", which if translated word-by-word is "I will the book soon read."
        Spanish has adjectives after the nouns they modify.
      </p>
      <p>
        While each language has its own organizational rules, they all do the
        same thing. They allow us to organize and express our thinking.
      </p>
      <h3>Functions - a fundamental organization concept of Kotlin</h3>
      <p>
        Python and Kotlin, being related languages, both have functions as a
        fundamental organizational structure. In all computer languages,
        functions are just realized algorithms. When you truly begin thinking in
        Kotlin, you will be thinking in algorithms. You will think of how
        algorithms are related to each other. You will have thoughts along these
        lines, "If this algorithm uses that one..." You will be able to do this
        since you will eventually realize that when you are designing solutions
        in Kotlin, how an algorithms accomplishes something is not as important
        as that it will, and that you can wait to figure out how to complete the
        algorithms later.
      </p>

      <p>
        In Python and Kotlin there are similarities and differences between the
        languages regarding how you declare functions. In Kotlin, the
        <kbd>fun</kbd> keyword is used instead of <kbd>def</kbd>. Also, in
        Kotlin the convention used for names of functions, parameters, and
        variables is called
        <a href="https://en.wikipedia.org/wiki/Camel_case">camel case</a>. To
        create a name, the first word of the name starts with a lower-case
        letter, and the first letter of all the rest of the words making up the
        name begin with an upper-case letter. For example, a function that
        averages two Doubles and returns a Double could be defined like this
      </p>

      <pre>
<code class="Kotlin">fun averageTwoNumbers(firstNum: Double, secondNum: Double) : Double{
  (firstNum+secondNum)/2
}</code></pre>
      <p>
        with the <kbd>:</kbd> operator indicating the type of the function's
        value.
      </p>
      <p>
        Notice the <kbd>{</kbd> and <kbd>}</kbd> operators. These are the Kotlin
        scope operators. These are used instead of the white-space scope
        operator used in Python. When Kotlin is compiled, white space is
        irrelvant. However, when writing your code, it is important to use white
        space to help make your code easier to read.
      </p>
      <p>
        Additionally, the name and type of the parameters must be declared with
        the type following the parameter name and separated by a colon as if you
        were declaring variables.
      </p>
      <p>
        Unlike some other languages, all Kotlin functions require the use of the
        return keyword unless the function has no value. Below is an example of
        a multi-line function.
      </p>
      <p></p>
      <pre>
<code class="Kotlin">fun averageTwoNumbers(firstNum: Double, secondNum: Double) : Double{
  val sum = firstNum+secondNum
  val avg = sum/2
  return avg
}</code></pre>
      <p>
        Here is an example of a Kotlin function that has parameters but no
        return value.
      </p>

      <pre>
<code class="Kotlin">fun printSum(firstNum: Double, secondNum: Double){
    println(firstNum+secondNum)
}</code></pre>
      <p>
        Notice that there is no <kbd>return</kbd> operator at the end of the
        declaration. This reduces redundant code.
      </p>
      <p>
        What if there are no parameters and no return value? Here is an example.
      </p>
      <pre>
<code class="Kotlin">fun printSillyMessage(){
    println("Don't be silly.")
}</code></pre>
      <p>
        Any function in any Kotlin file is available to use in any other file as
        long as the two files are in the same project. No import declaration is
        needed. Here is an example:
      </p>
      <pre>
<code class="Kotlin">//in file named stuff.kt

fun averageTwoNumbers(firstNum: Double, secondNum: Double) : Double {
  return (firstNum+secondNum)/2
}</code>
  </pre>
      <pre><code class="Kotlin">//in main.kt

print(averageTwoNumbers(firstNum:5.0,secondNum:3.0))</code></pre>
      <p>
        Notice that when the average function is used, the names of each
        parameter is required.
      </p>

      <h2>Conditional Branching - ifs and other amazing things</h2>
      <p>
        If statements are fine. In fact sometimes they are exactly what you
        want...but often there are better options. One of those options is
        called the elvis operator. In Kotlin, elvis operators can be used to
        keep the rest of the code in your function safe.
      </p>
      <p>
        Consider a situation where you need a function to check the viability of
        a password. It can be done with if-else statements, but why not use
        something that succinctly states the purpose of the code? Here is an
        example where the only requirement is that the password is not
        <kbd>null</kbd>.
      </p>
      <pre><code class="Kotlin">fun evaluatePassword(aPotentialPassword:String?) : Bool{
    val e = aPotentialPassword ?: return false
    //code here for if the string does pass the guard
    return true
}</code></pre>
      <p>
        Could this be done with an if statement? Absolutely. But using the elvis
        operator indicates to whoever is reading your code that this conditional
        statement is there so the function won't fail. Can you have multiple
        elvis operators in a function? You bet. Do they all have to go at the
        beginning of the function? Nope. You can put them anywhere that makes
        the best sense.
      </p>
      <p>
        If statements are to be used when choosing between different
        computational flows, not keeping your code safe. Here is an example.
      </p>
      <pre><code class="Kotlin">if (aNumber < 0.0) {
    println("$aNumber is negative")
}
else if (aNumber > 0.0) {
    println("$aNumber is positive")
}
else{
    println("$aNumber is zero")
}</code></pre>
      <p>
        In Kotlin <kbd>if-else</kbd> clauses can have a value. That means you
        can store the result of these clauses when it makes sense. For example,
        you could have written the code snippet above like this:
      </p>
      <pre><code class="Kotlin">val description = if (aNumber < 0.0) {
    "$aNumber is negative"
}
else if (aNumber > 0.0) {
    "$aNumber is positive"
}
else{
    "$aNumber is zero"
}
println(description)</code></pre>
      <p>This can save you from typing extraneous code.</p>
      <h2>Handling Exceptions</h2>
      <p>
        When exceptional event happen in your code, you should use
        <kbd>Exceptions</kbd> to deal with them. Kotlin runs on the Java Virtual
        Machine. Therefore Kotlin uses Java's <kbd>Exceptions</kbd> and
        exception handling tools. These exceptions are not intended to replace
        if-else constructs. Instead, they are to be used to deal with situations
        where your code could crash in other languages.
      </p>
      <p>
        There are two keywords used when dealing with <kbd>Exceptions</kbd>,
        <kbd>try</kbd> and <kbd>catch</kbd>. The idea here is your code tries to
        do something and if it fails the failure is dealt with by catching an
        <kbd>Exception</kbd> that describes the failure that happened. Here is a
        silly example.
      </p>
      <pre><code class="Kotlin"> try {
  //some code here to get the sum and the count
  .
  .
  .
  val mean = sum/count
  //the code that depends on mean being calculated correctly goes here
  .
  .
  .
  .
}
catch(e:Exception) {
  //put code here to deal with the Exception if something goes wrong
  .
  .
  .
}</code></pre>
      <p>
        As you know it is illegal to divide by zero. If the <kbd>count</kbd> of
        the numbers being averaged is zero, a division-by-zero exception will
        happen. In programming parlance, the <kbd>Exception</kbd> will be thrown
        so it can be caught by <kbd>catch</kbd>. Any code in the
        <kbd>try</kbd> keyword's scope that is after the line that throws the
        <kbd>Exception</kbd> is skipped. That code is only executed if no
        <kbd>Exception</kbd> is thrown.
      </p>
      <p>
        Since <kbd>try</kbd> and <kbd>catch</kbd> control the flow of your code,
        sometimes it is tempting to use exceptions and their handling instead of
        <kbd>if-then-else</kbd> clauses. Don't fall for this mistake. Exceptions
        are expensive to create and handle. Use them judiciously.
      </p>
      <p>
        There are some functions that don't catch and deal with
        <kbd>Exceptions</kbd> that happen within themselves. Instead they
        <kbd>throw</kbd> these <kbd>Exceptions</kbd> to let you know something
        went wrong and the writer of the function doesn't know how to deal with
        the problem. You, the programmer using their functions, are then
        responsible to react to the problem correctly with respect to the
        situation and needs of your application. An example of this is the
        <a href="https://www.tutorialkart.com/kotlin/kotlin-string-to-int/"
          ><kbd>String</kbd> method, <kbd>toInt</kbd></a
        >.
      </p>
      <p>
        Consider this situation, your app asks a user to enter their age. If
        they type in "duck" there is going to be a problem. The
        <kbd>toInt</kbd> method writers don't know how to deal with the problem.
        Therefore they have their code throw a
        <kbd>NumberFormatException</kbd> since the string wasn't formatted as a
        number.
      </p>
      <p>
        Your code needs to have <kbd>try</kbd> and <kbd>catch</kbd> keywords
        that deal with the exception. You are the one that knows what to tell
        the user. Therefore it is your responsibility.
      </p>

      <pre><code class="Kotlin"> try {
  //some code here to get the user's age
  .
  .
  .
  val age = ageAsString.toInt()
  //the code that depends on the age actually being a number goes here
  .
  .
  .
  .
}
catch(e:Exception) {
  //put code here to deal with the Exception if something goes wrong
  .
  .
  .
}</code></pre>

      <!- Maybe some stuff here about the let, run, also, scoping functions. !>

      <h2>Map, Filter, and Reduce</h2>
      <p>
        As with other languages that have map, filter, and reduce BIF's, you
        should use those when working with lists. The access operator,
        <kbd>[]</kbd>, is great, but when over-applied it can lead to a lot of
        bugs. So let's take a look at how Kotlin does map, filter and reduce.
        Like the implementations you've used before, these BIF's have a lambda
        function as a parameter.
      </p>
      <h3>Map</h3>
      <p>
        Suppose you had an Array of doubles and you needed to square get the
        square of each element. Here is a really verbose way of doing this in
        Kotlin. You'll see how we can clean this up in a minute.
      </p>
      <pre><code class="Kotlin">var squaredNumbers = numbers.map(fun (value: Double) : Double {
    return value * value
})</code></pre>
      <p>
        The lambda function, called a closure in Kotlin, is the only parameter
        to the map function. The <kbd>{</kbd> and <kbd>}</kbd> scope operators
        show you where the closure begins and ends. Right after the
        <kbd>{</kbd> operator you'll find the closure's signature. It has one
        parameter called <kbd>value</kbd> of type <kbd>Double</kbd> and returns
        a Double.
      </p>
      <p>
        Closures are a very important part of Kotlin. There are some ways you
        can use to reduce the amount of code you have to type to use one. If a
        function has a closure as its last parameter, the closure can be moved
        to after the call of the function. This removes the need to keep that
        closing <kbd>)</kbd> way down in other lines of your code. The snippet
        below shows how this works.
      </p>

      <pre><code class="Kotlin">var squaredNumbers = numbers.map { value -> value * value }</code></pre>

      <p>
        That change cleans it up a lot. The compiler knows the type of the
        elements of the Array, it knows the type of the parameter and the return
        type already, so that means you don't have to type in the signature of
        the closure if you don't want to. Also, the value of the last line of
        the closure is always returned. That way you don't need to use the
        <kbd>return</kbd> keyword.
      </p>
      <p>
        Getting rid of the signature means you don't have a name for the
        incoming variable. The <kbd>it</kbd> keyword is Kotlin's way of getting
        the single parameter. The snippet below shows a new, reduced version of
        using map that does the same thing as the previous snippet.
      </p>

      <pre><code class="Kotlin">var squaredNumbers = numbers.map { it * it }</code></pre>

      <p>
        Check that out! This is a most succinct use of the map function. You can
        choose to use any of these versions, but remember that the fewer things
        you have to type, the fewer bugs you're going to write. Less code is
        good code. As always, do what will make the code most readable for those
        who will be reading your code after you've gone. The last version is the
        one that is the most idiomatically Kotlin. That's probably the one you
        should use for simpler lambdas and reserve the others for when you may
        be using a parameter multiple times or in multiple ways.
      </p>
      <h3>Filter</h3>
      <p>
        The <kbd>filter</kbd> method also has only one parameter, and that
        parameter is also a closure. While we could show you all the longer,
        typing intensive ways, they would look nearly identical to the
        <kbd>map</kbd> examples we just showed you. So let's jump right to the
        most succinct version.
      </p>

      <pre><code class="Kotlin">val bigNumbers = numbers.filter { it > 12.0 }</code></pre>

      <h3>Reduce</h3>
      <p>
        The <kbd>reduce</kbd> method is a little different. It has two
        parameters so you do things a little differently when you want to
        decrease the amount of typing you need. The first parameter of
        <kbd>reduce</kbd> is the accumulator you've used in other languages. The
        second is the closure to apply when doing the reduction.
      </p>
      <p>
        The parameters of the closure are <kbd>$0</kbd>, the accumulating value,
        and <kbd>$1</kbd> the next value from the Array to accumulate. That
        means you can use the reduce function and apply some, but not all, of
        the tips that you saw for the <kbd>map</kbd> and
        <kbd>filter</kbd> functions. The snippet below shows how to use
        <kbd>0.0</kbd> as the initial value for the accumulator to sum all the
        values in the <kbd>numbers</kbd> Array.
      </p>
      <pre><code class="Kotlin">val sum = names.reduce { accumulator, anInt -> accumulator + anInt }</code></pre>
      <p>
        The compiler knows the second parameter of reduce is a closure. It also
        knows that the two parameters are going to be reduced to one value that
        is returned. All reduce actually needs to know is how to do the
        reduction. That means all you have to do is give it variable names for
        the accumulator, the incoming value from the array or list, and show how
        to combine them. That is done on the right of the
        <kbd>-></kbd> operator.
      </p>
      <p>Isn't that amazing?</p>
      <h3>Using Them Together</h3>
      <p>
        Suppose I had the Array <kbd>numbers</kbd> and needed to first filter
        it, then map it, and then reduce it. I could do that on multiple lines
        of code or....
      </p>

      <pre><code class="Kotlin">val sumOfFilteredSquares = numbers.filter{ it > 12 }.map{ it * it }.reduce{ acc, anInt -> acc + anInt }</code></pre>

      <h4>Other Options</h4>
      <p>
        If there is just no way to combine <kbd>map</kbd>, <kbd>filter</kbd>,
        and <kbd>reduce</kbd> to accomplish what you need to do, you can always
        fall back to using a <kbd>for</kbd> loop. Please remember that using
        this loop is a last choice, not a first choice. Using a
        <kbd>for</kbd> loop dramatically increases the probability of creating
        buggy code. Always use <kbd>map</kbd>, <kbd>filter</kbd>, and
        <kbd>reduce</kbd>
        if you can.
      </p>
      <p>
        If you are using a loop with an Array, use the <kbd>for-in</kbd> loop.
        Let's reuse the <kbd>numbers</kbd> Array from earlier. The code snippet
        below prints out each element in the Array.
      </p>

      <pre><code class="Kotlin">for (number in numbers) {
  println(number)
}</code></pre>

      <p>
        I can not emphasize enough that the <kbd>for-in</kbd> loop should not be
        used unless there is no other way to accomplish what you need to do
        using <kbd>map</kbd>, <kbd>filter</kbd>, and <kbd>reduce</kbd>. That
        type of situation is very rare.
      </p>
      <p>
        If you are not working with an Array, there is another way to use the
        <kbd>for-in</kbd> loop. In this situation there is a range of numbers
        that is the data. In the snippet below, the numbers printed out will be
        <kbd>1</kbd> to and including <kbd>100</kbd>.
      </p>

      <pre><code class="Kotlin">for (number in 1..100){
  println(number)
}</code></pre>

      <p>
        If you want to count down rather than up, you can use the
        <kbd>downTo</kbd> operator as you see in this snippet.
      </p>

      <pre><code class="Kotlin">for (number in 100 downTo 1){
  println(number)
}</code></pre>

      <p>
        The use of the <kbd>for-in</kbd> loop with a range are valid uses as
        long as you don't try to use the numbers as indexes of an Array. Such
        situations are rare. Most data is stored in Arrays or other data
        collections you'll find out about in Week 4.
      </p>
      <p>
        Kotlin also has a logical loop called <kbd>while</kbd>. Consider a
        situation where you are asking the user of your application for a value
        in <kbd>1</kbd> through <kbd>10</kbd>. If they enter anything outside
        that range you give them additional instructions and then ask again. The
        code snippet below is one way this can be done.
      </p>

      <pre><code class="Kotlin">while (input <= 1 || input > 10){
  //code here to get user information and assign it to
  //the input variable
}</code></pre>

      <p>
        Logical loops are valid as long as you don't try to twist them to
        iterate over the elements of an Array or some other collection of data.
      </p>
      <h2>A Final Comment</h2>
      <p>
        As with all languages, it is important to write Kotlin code
        idiomatically. That means you should follow the
        <a href="https://kotlinlang.org/docs/coding-conventions.html"
          >code conventions</a
        >
        the Kotlin community has decided on. When you do, your code will be
        cleaner, run faster, and be easier to read. Make sure you read through
        and follow the
        <a href="https://kotlinlang.org/docs/coding-conventions.html"
          >Kotlin coding conventions</a
        >.
      </p>

      <h2>Wrap Up</h2>
      <p>
        While there was a lot covered in this reading, you've seen these
        concepts before. Python has many of these concepts. The syntax is
        different for Kotlin and there are some new things you can do because of
        the compiler, but over all the concepts are the same.
      </p>
      <p>
        Differences are good. If all computer languages were the same, they'd
        all be the same language. Then we'd be stuck. We wouldn't be able to
        select languages to use based on what the languages are good at.
      </p>
    </main>
    <footer>
      <a
        rel="license"
        href="http://creativecommons.org/licenses/by/4.0/"
        target="_blank"
        ><img
          alt="This work is licensed under a Creative Commons Attribution 4.0 International License"
          style="border-width: 0"
          src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a
      ><br />This work is licensed under a
      <a
        rel="license"
        href="http://creativecommons.org/licenses/by/4.0/"
        target="_blank"
        >Creative Commons Attribution 4.0 International License</a
      >.
    </footer>
  </body>
</html>
