<!-- uses https://highlightjs.org/
-->

<html>
  <head>
    <link
      rel="shortcut icon"
      href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico"
      type="image/x-i        con"
    />
    <script type="text/javascript">
      var codeType = "JavaScript";
    </script>
    <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
    <link
      rel="stylesheet"
      href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css"
    />
    <link
      rel="stylesheet"
      href="https://byui-cse.github.io/Language-Courses/site/weekly.css"
    />
    <script
      type="text/javascript"
      src="https://byui-cse.github.io/Language-Courses/site/weekly.js"
    ></script>
  </head>

  <body onload="fetchSource()">
    <header class="hero-image">
      <section class="hero-text">
        <h1>CSE 222b: Week 02</h1>
        <p>The Fundamentals</p>
      </section>
    </header>
    <main>
      <h1>Some Similarities and Differences</h1>
      <h3>Shared Operators</h3>
      <p>
        Remember, both Python and Kotlin have C as one of their ancestors.
        Because of this, it is not shocking to find out that they share some of
        the same C-type operators. These include +, -, /, *, ==, !=, &lt, &gt,
        etc. Go to these two sites, and can compare the operators for the
        two languages.
        <a
          href="https://www.tutorialspoint.com/python/python_basic_operators.htm"
          target="_blank"
          >Python's list of operators</a
        >
        to
        <a
          href="https://www.educba.com/kotlin-operators/"
          target="_blank"
          >Kotlin's list of operators</a>. When you compare operators for the two languages, you will find that Python has a few that Kotlin
        does not and that Kotlin has a few that Python does not. You will also see that the conditional operators, also known
        as logical operators, exist in both languages but use different
        characters.
      </p>
      <h3>Kotlin's missing operators</h3>
      <p>
        Because Python and Kotlin are different languages and the creators
        of Kotlin had different opinions than those who created Python,
        there are some Python operators you should not expect to find in
        Kotlin. They are:
      </p>
      <ul>
        <li>// - the floor division operator</li>
        <li>&lt&gt - an alternative to !=</li>
        <li>**= - the exponent and assign operator</li>
        <li>and - the logical and operator</li>
        <li>or - the locical or operator</li>
        <li>not - the logical not operator</li>
      </ul>
      <p>
        Don't get the wrong idea. Each of these behaviors can be done in
        Kotlin, they will just be done a little differently. Take a look at
        Table 1 to see how.
      </p>

      <table class="blueTable">
        <caption>
          Table 1: Kotlin Equivalents of Python Operators
        </caption>
        <thead>
          <tr>
            <th>Python</th>
            <th>Kotlin</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>a//b</td>
            <td>a/b (for integers a and b)</td>
          </tr>
          <tr>
            <td>a &lt&gt b</td>
            <td>a != b</td>
          </tr>
          <tr>
            <td>a**=b</td>
            <td>a = a.pow(b) (for floating point type numbers a and b)</td>
          </tr>
          <tr>
            <td>a and b</td>
            <td>a && b</td>
          </tr>
          <tr>
            <td>a or b</td>
            <td>a || b</td>
          </tr>
          <tr>
            <td>not(a and b)</td>
            <td>!(a && b)</td>
          </tr>
        </tbody>
      </table>

      <p>
        Remember, Kotlin has
        <a
          href="https://www.educba.com/kotlin-operators/"
          target="_blank"
          >other operators</a
        >
        available as well.
      </p>
      <h3>Variables</h3>
      <p>
        In Python, a variable can hold any type of value and can change the type
        of value it holds. For example, this code is valid in Python.
      </p>
      <pre>
<code class="Python">age = 3
age = 5
age = 4.2
age = 'old'</code>
	</pre>
      <p>
        Kotlin has both variables and constants. Unlike in Python,
        each variable or constant in Kotlin can hold only one type and that type can not change. In Kotlin you use the 
        var keyword to declare a variable. Like this:
      </p>
      <p>
      <pre>
<code class="Kotlin">var age = 3
age = 5
age = "4"//compilation failure, type change
age = 4.2//compilation failure, type change
age = "old"//compilation failure, type change</code>
	</pre>
  </p>
    <p>
      Kotlin uses what is called <a href="https://www.merriam-webster.com/dictionary/interpolate" target="_blank">'interpolation'</a> 
      to figure out the type of the variable. In the code above, the compiler 
      discovered that the variable age is of type Integer because 3 is an Integer and inserted the Int keyword into the compiled code. 
      In the code snippet below, the compiler 
      discovers that the height variable is of type Double because 3.25 is a Double. Double being one of Kotlin's basic types of floating point numbers.
    </p>
    <p>
      <pre>
<code class="Kotlin">var height = 3.25
height = 4.2
height = 4//no compilation failure, 4 is converted to a Double
height = age//compilation failure, age's type in the previous example doesn't match
height = "tall"//compilation failure, type change</code>
  </pre>
  </p>
  <p>Here is an example where the compiler interpolates a variable to be of type String.</p>
  <p>
      <pre>
<code class="Kotlin">var name = "Sue"
name = "Gunhilda"
name = "7"
name = 4//compilation failure, type change
name = age//compiliation failure, age's type in the previous example doesn't match
name = 3.1456778889547637653//compilation failure, type change</code>
  </pre>
  </p>
      <h3>Constants</h3>
      <p>In Python, constants are declared using an all upper case name, a hold-over from its C ancestor.</p>

      <pre>
<code class="Python">PI=3.14</code>
	</pre>
      <p>
        In Kotlin this is done differently. If you are creating class or instance constants, upper snake-case
        names are used. If you are creating a local constant, lower snake-case is used. 
        Kotlin requires the use of the <kbd>let</kbd> keyword in both of these cases. Like this:
      </p>
      <pre>
<code class="Kotlin">let PI = 3.14
let BASE_VALUE = 3147
let div_result = 3/4</code>
	</pre>
      <p>
        For more information about declaring and using variables and constants in Kotlin
        please go and watch
        <a
          href="https://www.youtube.com/watch?v=iJ11StpAhCk"
          target="_blank"
          rel="noreferrer"
          >Kotlin Variables - var vs. let explained</a> now.
      </p>
      <h3>But I Want More Control!</h3>
      <p>
        Well...sometimes you do and sometimes you don't. You can tell the Kotlin compiler the type of a variable 
        instead of allowing it to interpolate it with any <a href="https://www.tutorialspoint.com/Kotlin/Kotlin_variables.htm" target="_blank">basic Kotlin type</a>. 
        For example, 
              <pre>
<code class="Kotlin">val   PI : Double = 3.14</code>
  </pre>
      creates a constant called pi of type Float, a floating point number type that uses fewer bytes of RAM than a variable of type Double. Also, 
       <pre>
<code class="Kotlin">var name : String = "Sue"</code>
  </pre>
      creates a variable called 'name' of type String and sets the value to be Sue.
      </p>
      <p>
        Kotlin has something analogous the Python's None. In Kotlin it is <kbd>null</kbd>. Declaring the type of a variable is required if the variable is initialized to <kbd>null</kbd>. 
        Think about this for a minute and take a look at this code snippet. 
        <pre>
<code class="Kotlin">var city = null</code>
  </pre>
        Here, the compiler can't interpolate a type for the city variable because nil has no type! That code won't compile.
      </p>
      <p>
        Instead, Kotlin will require you to add in the type. You might think, based on previous programming experience, that this code snippet would compile 
        <pre>
<code class="Kotlin">var city:String = null</code>
  </pre>
        but that would also be incorrect. This code will also fail to compile and you will get an error message that includes a '?' character. This is 
        because Kotlin is designed to be safer than other languages you may have used. Instead, you would need a variable that is a 'Nullable' type.
      </p>
      <h3>Nullables</h3>
      <p>
        In Kotlin, variables of type Nullable are either nil, or are wrappers around regular variable types. For example, this code snippet
        <pre>
<code class="Kotlin">var city:String? = null</code>
  </pre>
       reads, in English, like this. "Create a variable called city of type String Nullable and set it to null." If you later figure out what the city 
       variable should be set to, you can have the city variable wrap a value by doing something similar to this.
        <pre>
<code class="Kotlin">city = "Kinshasa"</code>
  </pre>
      The compiler takes care of all the wrapping up of the string Kinshasa in the String Nullable for you. You don't need to add any extra code. After 
      assigning "Kinshasa" to the String Nullable city, the city String Nullable now is wrapped around the String "Kinshasa".
      </p>
      <p>
        When you have a String Nullable and want to get the string back out, you use the <kbd>!!</kbd> operator. Be careful! If you try this
  <pre>        
<code class="Kotlin">print(city!!)</code>
  </pre>
       and city is null, you will get a runtime failure with a message saying that an unexpected null was found. These Nullables come in VERY handy and it is EASY 
       to check to see if something is null using Nullables. Take a look at the following snippet.

  <pre>        
<code class="Kotlin">print(city ?: "Unknown")</code>
  </pre>
      This code prints "Unknown" if the String Nullable <kbd>city</kbd> is <kbd>null</kbd>, or the value wrapped by the String Nullable if <kbd>city</kbd> is not <kbd>null</kbd>. This is due to the 
      elvis operator, <kbd>?:</kbd>. That's its job. In this case, Kinshasa is printed out since city is not <kbd>null</kbd>.
      </p>
      <h3>Wrap Up</h3>

      <p>
        As with all things, there are pluses and minuses of requiring keywords
        like <kbd>var</kbd> and <kbd>val</kbd> and having or not having some operators. One
        disadvantage of requiring <kbd>var</kbd> and <kbd>val</kbd> is the extra cluttering of the
        code with 'unnecessary' words. An advantage is explicitness. Everyone
        that later reads your code will know exactly what you meant to have
        happen. Also, because of this explicitness, a variable can't be
        accidentally declared twice in Kotlin, a situation which can produce
        strange, difficult to debug, bad behavior in large Python code sets.
      </p>
      <p>
        Which set of operators to include in a language often depends on the languages
        the creator likes and dislikes. Perhaps the creators of Python
        thought the syntax of Structured Query Language (SQL) was easier to
        understand and so they adopted the <kbd>and</kbd>, <kbd>or</kbd>, and <kbd>not</kbd> operators from SQL. The choices the creators make is based on opinion. Any other set of operators is just as valid. Don't get 
        caught up in the pseudo-religious fervor that some programmers adopt. Every language is good at some things 
        and bad at others. This includes both Python and Kotlin.
      </p>

      <h1>Arrays</h1>
      <p>In Kotlin, arrays can be declared like this if you want an array that can be modified. 
      <pre><code class="Kotlin">var names = arrayOf('Bob','Sue','Jorge','Svetlana')
	</code></pre>
      As with variables, if you don't want the compiler to interpolate the type of elements the array can hold, you 
      could write this same code snippet as
      <pre><code class="Kotlin">var names = arrayOf<String>('Bob','Sue','Jorge','Svetlana')
  </code></pre>

      If you want an array variable that can only hold the initial array but the values in that array can be changed, 
      use the <kbd>val</kbd> keyword like this.
          <pre><code class="Kotlin">val names = arrayOf('Bob','Sue','Jorge','Svetlana')
  </code></pre>
      These array declarations and assignments probably look very familiar to you.</p>
      <p>To access elements of an array, use the access operator <kbd>[]</kbd>
      <pre><code class="Kotlin">val aName = names[0]
	</code></pre>
        with zero being the index of the first element in the array. Not only can 
        you access the elements of the array, but you can modify them also.
      <pre class="Kotlin"><code>names[2]='George'
	</code></pre>
      After the previous line of code executes, the third element of the names array is George instead of Jorge.</p>
      <p>One of the goals of the developers of the Kotlin language is code safety. Because of this, if you attempt to 
      modify an array by using an index that is too large, your code will produce a runtime error instead of 
      writing to memory the application hasn't claimed like some other languages do. Yes C, I'm looking at you.</p>
      <p>
        That's why this code
        <pre><code class="Kotlin">names[4]='George'
  </code></pre>
        fails at runtime.
      </p>
      <h1>When Arrays Just Won't Work</h1>
      <p>
        While this way of creating arrays is great when you know all or most of the values that are to be stored in 
        the array, what if you don't know any of them? For example, you are loading a file that has all the values 
        for the array. What you do then is to declare an empty <kbd><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list.html">MutableList</a></kbd>.
      </p>
      <p>
        Let's say you are loading a bunch of names from a text file, from a database, or across a network. The 
        preferred way, there are several <a href="https://stackoverflow.com/questions/30430550/how-to-create-an-empty-array-in-Kotlin"></a> others, to declare a modifiable, empty array of Strings looks like this.
        <pre><code class="Kotlin">val names : MutableList<String> = mutableListOf()
  </code></pre>
        The translation of this line of code into English reads like this. "Create a value called 
        <kbd>names</kbd> of type MutableLists that holds Strings. Create an empty list Strings and assign it to the the <kbd>names</kbd> value."
        Since there is no way for the compiler to interpolate the type of values in an empty array, you have to 
        tell it the type. Also, you have to use the 
        <a href="https://www.techiedelight.com/add-elements-list-kotlin/"><kbd>add</kbd></a> or <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set.html"><kbd>set</kbd></a> 
        Built in Functions(BIF's)</a> to add to the array, not the accessor operator <kbd>[]</kbd>. However you can use 
        the accessor operator to get or set a value at an existing index. You just can't use it to add new indexes.
      </p>
      <p>
        Kotlin has a lot of <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/">BIF's</a> that work with 
        arrays. We'll cover some of these BIFs in detail during week 04 of this class.
      </p>
    <h1>Organization and Access</h1>
      <p>
        All computer languages are ways to organize your communication and
        thinking. In this, they are very similar to spoken languages. Each
        spoken language, or family of spoken languages, does this organization
        differently. English sentences often have a structure of Subject-Helper
        Verb-Verb-Predicate...The boy will bite the dog, for example. German, a
        language closely related to English, organizes things differently.
        Sometimes German sentences have a Subject-Helper Verb-Predicate-Verb
        structure... Ich werde das Buch bald lesen, which if translated
        word-by-word is "I will the book soon read." Spanish has adjectives
        after the nouns they modify.
      </p>
      <p>
        While each language has its own organizational rules, they all do the
        same thing. They allow us to organize and express our thinking.
      </p>
      <h3>Functions - a fundamental organization concept of Kotlin</h3>
      <p>
        Python and Kotlin, being related languages, both have functions as a
        fundamental organizational structure. In all computer languages, functions 
        are just realized algorithms. When you truly begin thinking in
        Kotlin, you will be thinking in algorithms. You will think of how
        algorithms are related to each other. You will have thoughts along these
        lines, "If this algorithm uses that one..." You will be able to do this
        since you will eventually realize that when you are designing solutions
        in Kotlin, how an algorithms accomplishes something is not as important
        as that it will, and that you can wait to figure out how to complete the
        algorithms later.
      </p>

      <p>
        In Python and Kotlin there are similarities and differences between
        the languages regarding how you declare functions. In Kotlin, the
        <kbd>fun</kbd> keyword is used instead of <kbd>def</kbd>. Also, in Kotlin the
        convention used for names of functions, parameters, and variables is called
        'camel case'. To create a name, the first word of the name starts with a
        lower-case letter, and the first letter of all the rest of the words
        making up the name begin with an upper-case letter. For example, a
        function that averages two Doubles and returns a Double could be defined like this
      <pre>
<code class="Kotlin">fun averageTwoNumbers(firstNum: Double, secondNum: Double) : Double{
  (firstNum+secondNum)/2
}</code>
  </pre>

        with the <kbd>:</kbd> operator indicating the type of the function's value. 
      <p>
        Notice the <kbd>{</kbd> and <kbd>}</kbd> operators. These are the Kotlin scope
        operators. These are used instead of the white-space scope operator used
        in Python. In Kotlin, white space means nothing but when writing
        your code, it is important to use white space to help make your code
        easier to read. Never left justify your code.
      </p>
      <p>
        Additionally, the name and type of the parameters must be declared with the type following 
        the parameter name and separated by a colon as if you were declaring variables.
      </p>
      <p>
        Unlike some other languages, all Kotlin functions require the use of the 
        return keyword unless the function has no value. Below is an example of a multi-line function.
      </p>
      <p>
      <pre>
<code class="Kotlin">fun averageTwoNumbers(firstNum: Double, secondNum: Double) : Double{
  val sum = firstNum+secondNum
  val avg = sum/2
  return avg
}</code>
  </pre>
</p>
<p>
  Here is an example of a Kotlin function that has parameters but no return value. 
  <pre>
<code class="Kotlin">fun printSum(firstNum: Double, secondNum: Double){
    println(firstNum+secondNum)
}</code>
  </pre>
  Notice that there is no <kbd>return</kbd> operator at the end of the declaration. This reduces useless code.
</p>
<p>
  What if there are no parameters and no return value? Here is an example.
  <pre>
<code class="Kotlin">fun printSillyMessage(){
    println("Don't be silly.")
}</code>
  </pre>
</p>
<p>
  Any function in any Kotlin file is available to use in any other file as long as the two files are in the 
  same project. As long as this is so, no import declaration is needed. Here is 
  an example.
</p>
<p>
<pre>
<code class="Kotlin">//in file named stuff.kt

fun averageTwoNumbers(firstNum: Double, secondNum: Double) : Double{
  return (firstNum+secondNum)/2
}</code>
  </pre>
  <pre>
  <code class="Kotlin">//in main.kt

print(averageTwoNumbers(firstNum:5.0,secondNum:3.0))
}</code>
  </pre>
</p>
    <p>
     Notice that when the average function is used, the names of each parameter is required. A good IDE will 
     fill these in for you.
   </p>

<h2>Conditional Branching - ifs and other amazing things</h2>
      <p>
        If statements are fine. In fact sometimes they are exactly what you want...but often there are better options. One of those options is 
        called the elvis operator. In Kotlin, elvis operators can be used to keep the rest of the code in your function safe.
      </p>
      <p>
        Consider a situation where you need a function to check the viability of a password. It can be done with if-else statements, but why not use 
        something that succinctly states the purpose of the code? Here is a silly example where the only requirement is that the password is not <kbd>null</kbd>.
      </p>
      <p>
      <pre>
  <code class="Kotlin">fun evaluatePassword(aPotentialPassword:String?) : Bool{
    val e = aPotentialPassword ?: return false
    //code here for if the string does pass the guard
    return true
}
}</code>
  </pre>
      </p>
      <p>
        Could this be done with an if statement? Absolutely. But using elvis operator indicates to whoever is reading your code that 
        this conditional statement is there so the function won't fail. Can you have multiple elvis operators in a function? 
        You bet. Do they all have to go at the beginning of the function? Nope. You can put them anywhere that 
        makes the best sense.
      </p>
      <p>
        If statements are to be used when choosing between different computational flows, not keeping your code safe. Here is a 
        silly example.
      </p>
      <p>
      <pre>
  <code class="Kotlin">if (aNumber < 0.0) {
    println("$aNumber is negative")
}
else if (aNumber > 0.0) {
    println("$aNumber is positive")
}
else{
    println("$aNumber is zero")
}</code>
  </pre>
      </p>
      <p>
        In Kotlin <kbd>if-else if-else</kbd> clauses have value. That means you can store the result of these 
        clauses when that makes sense. For example, you could have written the code snippet above like this.
      </p>
      <p>
      <pre>
  <code class="Kotlin">val description = if (aNumber < 0.0) {
    "$aNumber is negative"
}
else if (aNumber > 0.0) {
    "$aNumber is positive"
}
else{
    "$aNumber is zero"
}
println(description)
  </code>
  </pre>
      </p>
      <p>
        This can save you from typing extraneous code.
      </p>
      <!- Maybe some stuff here about the let, run, also, scoping functions. !>
      <h3>Map, Filter, and Reduce</h3>
      <p>
        As with other languages that have map, filter, and reduce BIF's, you should use those when working with lists. The 
        access operator, <kbd>[]</kbd>, is great, but when over-applied it can lead to a lot of bugs. So let's take a look 
        at how Kotlin does map, filter and reduce. Like the implementations you've used before, these BIF's have a 
        lambda function as a parameter.
      </p>
      <h4>Map</h4>
      <p>
        Suppose for some strange reason you had an Array of doubles and you needed to square them all. Here is a really 
        verbose way of doing this in Kotlin. You'll see how we can clean this up in a minute.
      </p>
      <p>
      <pre>
  <code class="Kotlin">var squaredNumbers = numbers.map(fun (value: Double) : Double {
    return value * value
})
</code>
  </pre>
      </p>
      <p>
        The lambda function, called a closure in Kotlin, is the only parameter to the map function. The <kbd>{</kbd> and 
        <kbd>}</kbd> scope operators show you where the closure begins and ends. Right after the <kbd>{</kbd> operator 
        you'll find the closure's signature. It has one parameter called <kbd>value</kbd> of type <kbd>Double</kbd> and 
        returns a Double.
      </p>
      <p>
        Closures are such an important part of Kotlin that there are some ways you can use to reduce the amount of code 
        you have to type to use one. If a function that has a closure as its last parameter, the closure can be moved to 
        after the call of the function. This removes having to keep that closing <kbd>)</kbd> way down in other lines of 
        your code. The snippet below shows how this works.
      </p>
      <p>
      <pre>
  <code class="Kotlin">var squaredNumbers = numbers.map{value -> value * value}</code>
  </pre>
      </p>
      <p>
        That change cleans it up a lot. The compiler knows the type of the elements of the Array it knows the type of the parameter and the 
        return type already, so that means you don't have to type in the signature of the closure if you don't want.
        Also, the value of last line of the closure is always returned. That way you don't need to use the <kbd>return</kbd> keyword.
      </p>
      <p>
        Getting rid of the signature means you don't have a name for the incoming variable. The <kbd>it</kbd> keyword is Kotlin's way  
        of getting the value single parameter. 
        The snippet below shows a new, reduced version of using map that does the same thing as the previous snippet.
      </p>
      <p>
      <pre>
  <code class="Kotlin">var squaredNumbers = numbers.map{it * it}</code>
  </pre>
      </p>
      <p>
        There you go. This is a most succinct use of the map function. You can choose to use any of these versions, 
        but remember that the fewer things you have to type, the fewer bugs you're going to write. Less code is good code. 
        As always, do what will make the code most readable for those who will be reading your code after you've gone. 
        The last version is the one that is the most idiomatically Kotlin. That's probably the one you should use for 
        simpler lambdas and reserve the others for when you may be using a parameter multiple times or in multiple 
        ways.
      </p>
      <h4>Filter</h4>
      <p>
        The <kbd>filter</kbd> method also has only one parameter, and that parameter is also a closure. While we could show 
        you all the longer, typing intensive ways, they would look nearly identical to the <kbd>map</kbd> examples we just 
        showed you. So let's jump right to the most succinct version.
      </p>
      <p>
      <pre>
  <code class="Kotlin">var bigNumbers = numbers.filter{it > 12.0}
</code>
  </pre>
      </p>
      <h4>Reduce</h4>
      <p>
        The <kbd>reduce</kbd> method is a little different. It has two parameters so you do things a little differently 
        when you want to decrease the amount of typing you need. The first parameter of <kbd>reduce</kbd> is the accumulator 
        you've used in other languages. The second is the closure to apply when doing the reduction.
      </p>
      <p>
        The parameters of the closure are <kbd>$0</kbd>, the accumulating value, and <kbd>$1</kbd> the next value from the 
        Array to accumulate. That means you can use the reduce function and apply some, but not all, of the tips that you 
        saw for the <kbd>map</kbd> and <kbd>filter</kbd> functions. The snippet below shows how to use <kbd>0.0</kbd> as the 
        initial value for the accumulator to sum all the values in the <kbd>numbers</kbd> Array.
      </p>
      <p>
      <pre>
  <code class="Kotlin">let sum = numbers.reduce{ accumulator, anInt -> accumulator + anInt })
</code>
  </pre>
      </p>
      <p>
        The compiler knows the second parameter of reduce is a closure. It also knows that the two parameters are going to 
        be reduced to one value that is returned. All reduce actually needs to know is how to do the reduction. 
        That means all you have to do is give it variable names for the accumulator, the incoming value from the array 
        or list, and show how to combine them. That is done on the right of the <kbd>-></kbd> operator.
      </p>
      <p>
        That's so cool.
      </p>
      <h4>Using Them Together</h4>
      <p>
        Suppose I had the Array <kbd>numbers</kbd> and needed to first filter it, then map it, and then reduce it. 
        I could do that on multiple lines of code or.... 
      </p>
      <p>
      <pre>
  <code class="Kotlin">val sumOfFilteredSquares = numbers.filter{it>12}.map{it*it}.reduce{ acc, anInt -> acc + anInt }
</code>
  </pre>
      </p>
      <h4>Other Options</h4>
      <p>
        If there is just no way to combine <kbd>map</kbd>, <kbd>filter</kbd>, and <kbd>reduce</kbd> to accomplish 
        what you need to do, you can always fall back to using a <kbd>for</kbd> loop. Please remember that using 
        this loop is a last choice, not a first choice. Using a <kbd>for</kbd> loop dramatically increases 
        the probability of you creating buggy code. Always use  <kbd>map</kbd>, <kbd>filter</kbd>, and <kbd>reduce</kbd> 
        if you can.
      </p>
      <p>
        If you are using a loop with an Array, use the <kbd>for-in</kbd> loop. Let's reuse the <kbd>numbers</kbd> Array 
        from earlier. The code snippet below prints out each element in the Array.
      </p>
      <p>
      <pre>
  <code class="Kotlin">for (number in numbers){
  println(number)
}
</code>
  </pre>
      </p>
      <p>
        I can not emphasize enough that the <kbd>for-in</kbd> loop should not be used unless there is no other way to 
        accomplish what you need to do using <kbd>map</kbd>, <kbd>filter</kbd>, and <kbd>reduce</kbd>. That type of situation 
        is very rare.
      </p>
      <p>
        If you are not working with an Array, there is another way to use the <kbd>for-in</kbd> loop. In this situation 
        there is a range of numbers that is the data. In the snippet below, the numbers printed out will be <kbd>1</kbd> 
        to and including <kbd>100</kbd>.
      </p>
      <p>
      <pre>
  <code class="Kotlin">for (number in 1..100){
  println(number)
}
</code>
  </pre>
      </p>
      <p>
        If you want to count down rather than up, you can use the <kbd>downTo</kbd>  operator as you see in this snippet.
      </p>
      <p>
      <pre>
  <code class="Kotlin">for (number in 100 downTo 1){
  println(number)
}
</code>
  </pre>
      </p>
      <p>
        The use of the <kbd>for-in</kbd> loop with a range are valid uses as long as you don't try to use the numbers 
        as indexes of an Array. Such situations are rare. Most data is stored in Arrays or other data collections 
        you'll find out about in week 04.
      </p>
      <p>
        Kotlin also has a logical loop called <kbd>while</kbd>. Consider a situation where you are asking the user of 
        your application for a value in <kbd>1</kbd> through <kbd>10</kbd>. If they enter anything outside that 
        range you give them additional instructions and then ask again. The code snippet below is one way this 
        can be done.
      </p>

      <p>
      <pre>
  <code class="Kotlin">while (input <= 1 || input > 10){
  //code here to get user information and assign it to
  //the input variable
}
</code>
  </pre>
      </p>
      <p>
        Logical loops are valid as long as you don't try to twist them to iterate over the elements of an Array or some 
        other collection of data.
      </p>

      <h2>Wrap Up</h2>
      <p>
        While there was a lot covered in this reading, you've seen these before. Python has each 
        of these types of things. The syntax is different for Kotlin and there are some new things you can do because 
        of the compiler, but over all the concepts are the same.
      </p>
      <p>
        Differences are good. If all computer languages were the same, they'd all be the same language. Then we'd 
        be stuck. We wouldn't be able to select languages to use based on what the languages are good at.
      </p>
      
    </main>
    <footer>
      <a
        rel="license"
        href="http://creativecommons.org/licenses/by/4.0/"
        target="_blank"
        ><img
          alt="This work is licensed under a Creative Commons Attribution 4.0 International License"
          style="border-width: 0;"
          src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a
      ><br />This work is licensed under a
      <a
        rel="license"
        href="http://creativecommons.org/licenses/by/4.0/"
        target="_blank"
        >Creative Commons Attribution 4.0 International License</a
      >.
    </footer>
  </body>
</html>
